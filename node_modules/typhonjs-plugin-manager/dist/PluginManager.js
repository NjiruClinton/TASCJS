'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _iterator25 = require('babel-runtime/core-js/symbol/iterator');

var _iterator26 = _interopRequireDefault(_iterator25);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _typhonjsObjectUtil = require('typhonjs-object-util');

var _typhonjsObjectUtil2 = _interopRequireDefault(_typhonjsObjectUtil);

var _EventProxy = require('backbone-esnext-events/dist/EventProxy');

var _EventProxy2 = _interopRequireDefault(_EventProxy);

var _PluginEntry = require('./PluginEntry.js');

var _PluginEntry2 = _interopRequireDefault(_PluginEntry);

var _PluginEvent = require('./PluginEvent.js');

var _PluginEvent2 = _interopRequireDefault(_PluginEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Provides a lightweight plugin manager for Node / NPM with optional `backbone-esnext-events`
 * integration for plugins in a safe and protected manner across NPM modules, local files, and preloaded object
 * instances. This pattern facilitates message passing between modules versus direct dependencies / method invocation.
 *
 * It isn't necessary to use an eventbus associated with the plugin manager though invocation then relies on invoking
 * methods directly with the plugin manager instance.
 *
 * When passing in an eventbus from `backbone-esnext-events` the plugin manager will register by default under these
 * event categories:
 *
 * `plugins:add` - {@link PluginManager#add}
 *
 * `plugins:add:all` - {@link PluginManager#addAll}
 *
 * `plugins:async:add` - {@link PluginManager#addAsync}
 *
 * `plugins:async:add:all` - {@link PluginManager#addAllAsync}
 *
 * `plugins:async:destroy:manager` - {@link PluginManager#destroyAsync}
 *
 * `plugins:async:invoke` - {@link PluginManager#invokeAsync}
 *
 * `plugins:async:invoke:event` - {@link PluginManager#invokeAsyncEvent}
 *
 * `plugins:async:remove` - {@link PluginManager#removeAsync}
 *
 * `plugins:async:remove:all` - {@link PluginManager#removeAllAsync}
 *
 * `plugins:create:event:proxy` - {@link PluginManager#createEventProxy}
 *
 * `plugins:destroy:manager` - {@link PluginManager#destroy}
 *
 * `plugins:get:all:plugin:data` - {@link PluginManager#getAllPluginData}
 *
 * `plugins:get:extra:event:data` - {@link PluginManager#getExtraEventData}
 *
 * `plugins:get:method:names` - {@link PluginManager#getMethodNames}
 *
 * `plugins:get:options` - {@link PluginManager#getOptions}
 *
 * `plugins:get:plugin:data` - {@link PluginManager#getPluginData}
 *
 * `plugins:get:plugin:enabled` - {@link PluginManager#getPluginEnabled}
 *
 * `plugins:get:plugin:event:names` - {@link PluginManager#getPluginEventNames}
 *
 * `plugins:get:plugin:method:names` - {@link PluginManager#getPluginMethodNames}
 *
 * `plugins:get:plugin:names` - {@link PluginManager#getPluginNames}
 *
 * `plugins:get:plugin:options` - {@link PluginManager#getPluginOptions}
 *
 * `plugins:get:plugins:enabled` - {@link PluginManager#getPluginsEnabled}
 *
 * `plugins:get:plugins:by:event:name` - {@link PluginManager#getPluginsByEventName}
 *
 * `plugins:get:plugins:event:names` - {@link PluginManager#getPluginsEventNames}
 *
 * `plugins:has:method` - {@link PluginManager#hasMethod}
 *
 * `plugins:has:plugin` - {@link PluginManager#hasPlugin}
 *
 * `plugins:has:plugin:method` - {@link PluginManager#hasPluginMethod}
 *
 * `plugins:invoke` - {@link PluginManager#invoke}
 *
 * `plugins:is:valid:config` - {@link PluginManager#isValidConfig}
 *
 * `plugins:remove` - {@link PluginManager#remove}
 *
 * `plugins:remove:all` - {@link PluginManager#removeAll}
 *
 * `plugins:set:extra:event:data` - {@link PluginManager#setExtraEventData}
 *
 * `plugins:set:options` - {@link PluginManager#setOptions}
 *
 * `plugins:set:plugin:enabled` - {@link PluginManager#setPluginEnabled}
 *
 * `plugins:set:plugins:enabled` - {@link PluginManager#setPluginsEnabled}
 *
 * `plugins:sync:invoke` - {@link PluginManager#invokeSync}
 *
 * `plugins:sync:invoke:event` - {@link PluginManager#invokeSyncEvent}
 *
 * Automatically when a plugin is loaded and unloaded respective callbacks `onPluginLoad` and `onPluginUnload` will
 * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus
 * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins
 * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without
 * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding
 * issues.
 *
 * The plugin manager also supports asynchronous operation with the methods ending in `Async` along with event bindings
 * that include `async`. For asynchronous variations of `add`, `destroy`, and `remove` the lifecycle methods
 * `onPluginLoad` and `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method
 * then it must complete before execution continues. One can use Promises to interact with the plugin manager
 * asynchronously, but usage via async / await is recommended.
 *
 * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as
 * `backbone-esnext-eventbus` to call {@link PluginManager#destroy} to clean up all plugin eventbus resources and
 * the plugin manager event bindings.
 *
 * @see https://www.npmjs.com/package/backbone-esnext-events
 * @see https://www.npmjs.com/package/backbone-esnext-eventbus
 *
 * @example
 * import Events        from 'backbone-esnext-events';   // Imports the TyphonEvents class for local usage.
 * ::or alternatively::
 * import eventbus      from 'backbone-esnext-eventbus'; // Imports a global / process level eventbus.
 *
 * import PluginManager from 'typhonjs-plugin-manager';
 *
 * const pluginManager = new PluginManager({ eventbus });
 *
 * pluginManager.add({ name: 'an-npm-plugin-enabled-module' });
 * pluginManager.add({ name: 'my-local-module', target: './myModule.js' });
 *
 * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.
 * // Let's say my-local-module responds to 'hot:event' which returns 'false'.
 * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin
 * // options defined.
 *
 * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.
 * assert(eventbus.triggerSync('cool:event') === true);
 * assert(eventbus.triggerSync('hot:event') === false);
 *
 * // One can also indirectly invoke any method of the plugin via:
 * eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is invoked.
 * eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod', {}, {}, 'an-npm-plugin-enabled-module'); // specific invocation.
 *
 * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single
 * // event / object hash to the invoked method.
 *
 * // -----------------------
 *
 * // Given that `backbone-esnext-eventbus` defines a global / process level eventbus you can import it in an entirely
 * // different file or even NPM module and invoke methods of loaded plugins like this:
 *
 * import eventbus from 'backbone-esnext-eventbus';
 *
 * eventbus.triggerSync('plugins:invoke', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is invoked.
 *
 * assert(eventbus.triggerSync('cool:event') === true);
 *
 * eventbus.trigger('plugins:remove', 'an-npm-plugin-enabled-module'); // Removes the plugin and unregisters events.
 *
 * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!
 *
 * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the main
 * // thread of execution scope to remove all plugins and the plugin manager event bindings!
 */
var PluginManager = function () {
   /**
    * Instantiates PluginManager
    *
    * @param {object}   [options] - Provides various configuration options:
    *
    * @param {TyphonEvents}   [options.eventbus] - An instance of 'backbone-esnext-events' used as the plugin eventbus.
    *
    * @param {string}   [options.eventPrepend='plugin'] - A customized name to prepend PluginManager events on the
    *                                                     eventbus.
    *
    * @param {boolean}  [options.throwNoMethod=false] - If true then when a method fails to be invoked by any plugin
    *                                                   an exception will be thrown.
    *
    * @param {boolean}  [options.throwNoPlugin=false] - If true then when no plugin is matched to be invoked an
    *                                                   exception will be thrown.
    *
    *
    * @param {object}   [extraEventData] - Provides additional optional data to attach to PluginEvent callbacks.
    */
   function PluginManager() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extraEventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
      (0, _classCallCheck3.default)(this, PluginManager);

      if ((typeof options === 'undefined' ? 'undefined' : (0, _typeof3.default)(options)) !== 'object') {
         throw new TypeError('\'options\' is not an object.');
      }

      /**
       * Stores the plugins by name with an associated PluginEntry.
       * @type {Map<string, PluginEntry>}
       * @private
       */
      this._pluginMap = new _map2.default();

      /**
       * Stores any associated eventbus.
       * @type {TyphonEvents}
       * @private
       */
      this._eventbus = null;

      /**
       * Stores any extra options / data to add to PluginEvent callbacks.
       * @type {Object}
       * @private
       */
      this._extraEventData = extraEventData;

      /**
       * Defines options for throwing exceptions. Turned off by default.
       * @type {PluginManagerOptions}
       * @private
       */
      this._options = {
         pluginsEnabled: true,
         noEventAdd: false,
         noEventDestroy: false,
         noEventOptions: true,
         noEventRemoval: false,
         throwNoMethod: false,
         throwNoPlugin: false
      };

      if ((0, _typeof3.default)(options.eventbus) === 'object') {
         this.setEventbus(options.eventbus, options.eventPrepend);
      }

      this.setOptions(options);
   }

   /**
    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options
    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an
    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.
    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.
    *
    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.
    *
    * @param {object}         [moduleData] - Optional object hash to associate with plugin.
    *
    * @returns {PluginData|undefined}
    */


   (0, _createClass3.default)(PluginManager, [{
      key: 'add',
      value: function add(pluginConfig, moduleData) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if ((typeof pluginConfig === 'undefined' ? 'undefined' : (0, _typeof3.default)(pluginConfig)) !== 'object') {
            throw new TypeError('\'pluginConfig\' is not an \'object\'.');
         }

         if (typeof pluginConfig.name !== 'string') {
            throw new TypeError('\'pluginConfig.name\' is not a \'string\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');
         }

         if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string') {
            throw new TypeError('\'pluginConfig.target\' is not a string for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');
         }

         if (typeof pluginConfig.options !== 'undefined' && (0, _typeof3.default)(pluginConfig.options) !== 'object') {
            throw new TypeError('\'pluginConfig.options\' is not an \'object\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');
         }

         if (typeof moduleData !== 'undefined' && (typeof moduleData === 'undefined' ? 'undefined' : (0, _typeof3.default)(moduleData)) !== 'object') {
            throw new TypeError('\'moduleData\' is not an \'object\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');
         }

         // If a plugin with the same name already exists post a warning and exit early.
         if (this._pluginMap.has(pluginConfig.name)) {
            // Please note that a plugin or other logger must be setup on the associated eventbus.
            if (this._eventbus !== null && typeof this._eventbus !== 'undefined') {
               this._eventbus.trigger('log:warn', 'A plugin already exists with name: ' + pluginConfig.name + '.');
            }

            return void 0;
         }

         var instance = void 0,
             target = void 0,
             type = void 0;

         // Use an existing instance of a plugin; a static class is assumed when instance is a function.
         if ((0, _typeof3.default)(pluginConfig.instance) === 'object' || typeof pluginConfig.instance === 'function') {
            instance = pluginConfig.instance;

            target = pluginConfig.name;

            type = 'instance';
         } else {
            // If a target is defined use it instead of the name.
            target = pluginConfig.target || pluginConfig.name;

            if (target.match(/^[.\/\\]/)) {
               instance = require(_path2.default.resolve(target)); // eslint-disable global-require

               type = 'require-path';
            } else {
               instance = require(target); // eslint-disable global-require

               type = 'require-module';
            }
         }

         // Create an object hash with data describing the plugin, manager, and any extra module data.
         var pluginData = JSON.parse((0, _stringify2.default)({
            manager: {
               eventPrepend: this._eventPrepend
            },

            module: moduleData || {},

            plugin: {
               name: pluginConfig.name,
               scopedName: this._eventPrepend + ':' + pluginConfig.name,
               target: target,
               targetEscaped: _PluginEntry2.default.escape(target),
               type: type,
               options: pluginConfig.options || {}
            }
         }));

         _typhonjsObjectUtil2.default.deepFreeze(pluginData, ['eventPrepend', 'scopedName']);

         var eventProxy = this._eventbus !== null && typeof this._eventbus !== 'undefined' ? new _EventProxy2.default(this._eventbus) : void 0;

         var entry = new _PluginEntry2.default(pluginConfig.name, pluginData, instance, eventProxy);

         this._pluginMap.set(pluginConfig.name, entry);

         // Invoke private module method which allows skipping optional error checking.
         s_INVOKE_SYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, pluginConfig.name, this._pluginMap, this._options, false);

         // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.
         if (this._eventbus) {
            this._eventbus.trigger('typhonjs:plugin:manager:plugin:added', pluginData);
         }

         return pluginData;
      }

      /**
       * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options
       * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an
       * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.
       * By passing in `options` this will be stored and accessible to the plugin during all callbacks.
       *
       * @param {PluginConfig}   pluginConfig - Defines the plugin to load.
       *
       * @param {object}         [moduleData] - Optional object hash to associate with plugin.
       *
       * @returns {Promise<PluginData|undefined>}
       */

   }, {
      key: 'addAsync',
      value: function () {
         var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(pluginConfig, moduleData) {
            var instance, target, type, pluginData, eventProxy, entry;
            return _regenerator2.default.wrap(function _callee$(_context) {
               while (1) {
                  switch (_context.prev = _context.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        if (!((typeof pluginConfig === 'undefined' ? 'undefined' : (0, _typeof3.default)(pluginConfig)) !== 'object')) {
                           _context.next = 4;
                           break;
                        }

                        throw new TypeError('\'pluginConfig\' is not an \'object\'.');

                     case 4:
                        if (!(typeof pluginConfig.name !== 'string')) {
                           _context.next = 6;
                           break;
                        }

                        throw new TypeError('\'pluginConfig.name\' is not a \'string\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');

                     case 6:
                        if (!(typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string')) {
                           _context.next = 8;
                           break;
                        }

                        throw new TypeError('\'pluginConfig.target\' is not a string for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');

                     case 8:
                        if (!(typeof pluginConfig.options !== 'undefined' && (0, _typeof3.default)(pluginConfig.options) !== 'object')) {
                           _context.next = 10;
                           break;
                        }

                        throw new TypeError('\'pluginConfig.options\' is not an \'object\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');

                     case 10:
                        if (!(typeof moduleData !== 'undefined' && (typeof moduleData === 'undefined' ? 'undefined' : (0, _typeof3.default)(moduleData)) !== 'object')) {
                           _context.next = 12;
                           break;
                        }

                        throw new TypeError('\'moduleData\' is not an \'object\' for entry: ' + (0, _stringify2.default)(pluginConfig) + '.');

                     case 12:
                        if (!this._pluginMap.has(pluginConfig.name)) {
                           _context.next = 15;
                           break;
                        }

                        // Please note that a plugin or other logger must be setup on the associated eventbus.
                        if (this._eventbus !== null && typeof this._eventbus !== 'undefined') {
                           this._eventbus.trigger('log:warn', 'A plugin already exists with name: ' + pluginConfig.name + '.');
                        }

                        return _context.abrupt('return', void 0);

                     case 15:
                        instance = void 0, target = void 0, type = void 0;

                        // Use an existing instance of a plugin; a static class is assumed when instance is a function.

                        if ((0, _typeof3.default)(pluginConfig.instance) === 'object' || typeof pluginConfig.instance === 'function') {
                           instance = pluginConfig.instance;

                           target = pluginConfig.name;

                           type = 'instance';
                        } else {
                           // If a target is defined use it instead of the name.
                           target = pluginConfig.target || pluginConfig.name;

                           if (target.match(/^[.\/\\]/)) {
                              instance = require(_path2.default.resolve(target)); // eslint-disable global-require

                              type = 'require-path';
                           } else {
                              instance = require(target); // eslint-disable global-require

                              type = 'require-module';
                           }
                        }

                        // Create an object hash with data describing the plugin, manager, and any extra module data.
                        pluginData = JSON.parse((0, _stringify2.default)({
                           manager: {
                              eventPrepend: this._eventPrepend
                           },

                           module: moduleData || {},

                           plugin: {
                              name: pluginConfig.name,
                              scopedName: this._eventPrepend + ':' + pluginConfig.name,
                              target: target,
                              targetEscaped: _PluginEntry2.default.escape(target),
                              type: type,
                              options: pluginConfig.options || {}
                           }
                        }));


                        _typhonjsObjectUtil2.default.deepFreeze(pluginData, ['eventPrepend', 'scopedName']);

                        eventProxy = this._eventbus !== null && typeof this._eventbus !== 'undefined' ? new _EventProxy2.default(this._eventbus) : void 0;
                        entry = new _PluginEntry2.default(pluginConfig.name, pluginData, instance, eventProxy);


                        this._pluginMap.set(pluginConfig.name, entry);

                        // Invoke private module method which allows skipping optional error checking.
                        _context.next = 24;
                        return s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, pluginConfig.name, this._pluginMap, this._options, false);

                     case 24:
                        if (!this._eventbus) {
                           _context.next = 27;
                           break;
                        }

                        _context.next = 27;
                        return this._eventbus.triggerAsync('typhonjs:plugin:manager:plugin:added', pluginData);

                     case 27:
                        return _context.abrupt('return', pluginData);

                     case 28:
                     case 'end':
                        return _context.stop();
                  }
               }
            }, _callee, this);
         }));

         function addAsync(_x3, _x4) {
            return _ref.apply(this, arguments);
         }

         return addAsync;
      }()

      /**
       * Initializes multiple plugins in a single call.
       *
       * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.
       *
       * @param {object}               [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {Array<PluginData>}
       */

   }, {
      key: 'addAll',
      value: function addAll() {
         var pluginConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
         var moduleData = arguments[1];

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!Array.isArray(pluginConfigs)) {
            throw new TypeError('\'plugins\' is not an array.');
         }

         var pluginsData = [];

         var _iteratorNormalCompletion = true;
         var _didIteratorError = false;
         var _iteratorError = undefined;

         try {
            for (var _iterator = (0, _getIterator3.default)(pluginConfigs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
               var pluginConfig = _step.value;

               var result = this.add(pluginConfig, moduleData);

               if (result) {
                  pluginsData.push(result);
               }
            }
         } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
               }
            } finally {
               if (_didIteratorError) {
                  throw _iteratorError;
               }
            }
         }

         return pluginsData;
      }

      /**
       * Initializes multiple plugins in a single call.
       *
       * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.
       *
       * @param {object}               [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {Promise<Array<PluginData>>}
       */

   }, {
      key: 'addAllAsync',
      value: function addAllAsync() {
         var pluginConfigs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
         var moduleData = arguments[1];

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!Array.isArray(pluginConfigs)) {
            throw new TypeError('\'plugins\' is not an array.');
         }

         var pluginsData = [];

         var _iteratorNormalCompletion2 = true;
         var _didIteratorError2 = false;
         var _iteratorError2 = undefined;

         try {
            for (var _iterator2 = (0, _getIterator3.default)(pluginConfigs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
               var pluginConfig = _step2.value;

               var result = this.addAsync(pluginConfig, moduleData);

               if (result) {
                  pluginsData.push(result);
               }
            }
         } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
               }
            } finally {
               if (_didIteratorError2) {
                  throw _iteratorError2;
               }
            }
         }

         return _promise2.default.all(pluginsData);
      }

      /**
       * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables
       * the ability for plugins to be added via events preventing any external code adding plugins in this manner.
       *
       * @param {PluginConfig}   pluginConfig - Defines the plugin to load.
       *
       * @param {object}         [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {PluginData|undefined} - Operation success.
       * @private
       */

   }, {
      key: '_addEventbus',
      value: function _addEventbus(pluginConfig, moduleData) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         return !this._options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;
      }

      /**
       * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables
       * the ability for plugins to be added via events preventing any external code adding plugins in this manner.
       *
       * @param {PluginConfig}   pluginConfig - Defines the plugin to load.
       *
       * @param {object}         [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {Promise<PluginData|undefined>} - Operation success.
       * @private
       */

   }, {
      key: '_addEventbusAsync',
      value: function _addEventbusAsync(pluginConfig, moduleData) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         return !this._options.noEventAdd ? this.addAsync(pluginConfig, moduleData) : _promise2.default.resolve(void 0);
      }

      /**
       * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables
       * the ability for plugins to be added via events preventing any external code adding plugins in this manner.
       *
       * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.
       *
       * @param {object}               [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {Array<PluginData>}
       * @private
       */

   }, {
      key: '_addAllEventbus',
      value: function _addAllEventbus(pluginConfigs, moduleData) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!this._options.noEventAdd) {
            return this.addAll(pluginConfigs, moduleData);
         }
      }

      /**
       * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables
       * the ability for plugins to be added via events preventing any external code adding plugins in this manner.
       *
       * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.
       *
       * @param {object}               [moduleData] - Optional object hash to associate with all plugins.
       *
       * @returns {Promise<Array<PluginData>>}
       * @private
       */

   }, {
      key: '_addAllEventbusAsync',
      value: function _addAllEventbusAsync(pluginConfigs, moduleData) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!this._options.noEventAdd) {
            return this.addAllAsync(pluginConfigs, moduleData);
         }
      }

      /**
       * If an eventbus is assigned to this plugin manager then a new EventProxy wrapping this eventbus is returned.
        *
       * @returns {EventProxy}
       */

   }, {
      key: 'createEventProxy',
      value: function createEventProxy() {
         return this._eventbus !== null ? new _EventProxy2.default(this._eventbus) : void 0;
      }

      /**
       * Destroys all managed plugins after unloading them.
       */

   }, {
      key: 'destroy',
      value: function destroy() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         this.removeAll();

         if (this._eventbus !== null && typeof this._eventbus !== 'undefined') {
            this._eventbus.off(this._eventPrepend + ':add', this._addEventbus, this);
            this._eventbus.off(this._eventPrepend + ':add:all', this._addAllEventbus, this);
            this._eventbus.off(this._eventPrepend + ':async:add', this._addEventbusAsync, this);
            this._eventbus.off(this._eventPrepend + ':async:add:all', this._addAllEventbusAsync, this);
            this._eventbus.off(this._eventPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
            this._eventbus.off(this._eventPrepend + ':async:invoke', this.invokeAsync, this);
            this._eventbus.off(this._eventPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
            this._eventbus.off(this._eventPrepend + ':async:remove', this._removeEventbusAsync, this);
            this._eventbus.off(this._eventPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
            this._eventbus.off(this._eventPrepend + ':create:event:proxy', this.createEventProxy, this);
            this._eventbus.off(this._eventPrepend + ':destroy:manager', this._destroyEventbus, this);
            this._eventbus.off(this._eventPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
            this._eventbus.off(this._eventPrepend + ':get:extra:event:data', this.getExtraEventData, this);
            this._eventbus.off(this._eventPrepend + ':get:method:names', this.getMethodNames, this);
            this._eventbus.off(this._eventPrepend + ':get:options', this.getOptions, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:data', this.getPluginData, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:names', this.getPluginNames, this);
            this._eventbus.off(this._eventPrepend + ':get:plugin:options', this.getPluginOptions, this);
            this._eventbus.off(this._eventPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
            this._eventbus.off(this._eventPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
            this._eventbus.off(this._eventPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
            this._eventbus.off(this._eventPrepend + ':has:method', this.hasMethod, this);
            this._eventbus.off(this._eventPrepend + ':has:plugin', this.hasPlugin, this);
            this._eventbus.off(this._eventPrepend + ':has:plugin:method', this.hasPluginMethod, this);
            this._eventbus.off(this._eventPrepend + ':invoke', this.invoke, this);
            this._eventbus.off(this._eventPrepend + ':is:valid:config', this.isValidConfig, this);
            this._eventbus.off(this._eventPrepend + ':remove', this._removeEventbus, this);
            this._eventbus.off(this._eventPrepend + ':remove:all', this._removeAllEventbus, this);
            this._eventbus.off(this._eventPrepend + ':set:extra:event:data', this.setExtraEventData, this);
            this._eventbus.off(this._eventPrepend + ':set:options', this._setOptionsEventbus, this);
            this._eventbus.off(this._eventPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
            this._eventbus.off(this._eventPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
            this._eventbus.off(this._eventPrepend + ':sync:invoke', this.invokeSync, this);
            this._eventbus.off(this._eventPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);
         }

         this._pluginMap = null;
         this._eventbus = null;
      }

      /**
       * Destroys all managed plugins after unloading them.
       */

   }, {
      key: 'destroyAsync',
      value: function () {
         var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
            return _regenerator2.default.wrap(function _callee2$(_context2) {
               while (1) {
                  switch (_context2.prev = _context2.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context2.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        _context2.next = 4;
                        return this.removeAll();

                     case 4:

                        if (this._eventbus !== null && typeof this._eventbus !== 'undefined') {
                           this._eventbus.off(this._eventPrepend + ':add', this._addEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':add:all', this._addAllEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':async:add', this._addEventbusAsync, this);
                           this._eventbus.off(this._eventPrepend + ':async:add:all', this._addAllEventbusAsync, this);
                           this._eventbus.off(this._eventPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
                           this._eventbus.off(this._eventPrepend + ':async:invoke', this.invokeAsync, this);
                           this._eventbus.off(this._eventPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
                           this._eventbus.off(this._eventPrepend + ':async:remove', this._removeEventbusAsync, this);
                           this._eventbus.off(this._eventPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
                           this._eventbus.off(this._eventPrepend + ':create:event:proxy', this.createEventProxy, this);
                           this._eventbus.off(this._eventPrepend + ':destroy:manager', this._destroyEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
                           this._eventbus.off(this._eventPrepend + ':get:extra:event:data', this.getExtraEventData, this);
                           this._eventbus.off(this._eventPrepend + ':get:method:names', this.getMethodNames, this);
                           this._eventbus.off(this._eventPrepend + ':get:options', this.getOptions, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:data', this.getPluginData, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:names', this.getPluginNames, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugin:options', this.getPluginOptions, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
                           this._eventbus.off(this._eventPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
                           this._eventbus.off(this._eventPrepend + ':has:method', this.hasMethod, this);
                           this._eventbus.off(this._eventPrepend + ':has:plugin', this.hasPlugin, this);
                           this._eventbus.off(this._eventPrepend + ':has:plugin:method', this.hasPluginMethod, this);
                           this._eventbus.off(this._eventPrepend + ':invoke', this.invoke, this);
                           this._eventbus.off(this._eventPrepend + ':is:valid:config', this.isValidConfig, this);
                           this._eventbus.off(this._eventPrepend + ':remove', this._removeEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':remove:all', this._removeAllEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':set:extra:event:data', this.setExtraEventData, this);
                           this._eventbus.off(this._eventPrepend + ':set:options', this._setOptionsEventbus, this);
                           this._eventbus.off(this._eventPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
                           this._eventbus.off(this._eventPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
                           this._eventbus.off(this._eventPrepend + ':sync:invoke', this.invokeSync, this);
                           this._eventbus.off(this._eventPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);
                        }

                        this._pluginMap = null;
                        this._eventbus = null;

                     case 7:
                     case 'end':
                        return _context2.stop();
                  }
               }
            }, _callee2, this);
         }));

         function destroyAsync() {
            return _ref2.apply(this, arguments);
         }

         return destroyAsync;
      }()

      /**
       * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is
       * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external
       * code removing plugins in this manner.
       *
       * @private
       */

   }, {
      key: '_destroyEventbus',
      value: function _destroyEventbus() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!this._options.noEventDestroy) {
            this.destroy();
         }
      }

      /**
       * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is
       * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external
       * code removing plugins in this manner.
       *
       * @private
       */

   }, {
      key: '_destroyEventbusAsync',
      value: function () {
         var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
            return _regenerator2.default.wrap(function _callee3$(_context3) {
               while (1) {
                  switch (_context3.prev = _context3.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context3.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        if (this._options.noEventDestroy) {
                           _context3.next = 5;
                           break;
                        }

                        _context3.next = 5;
                        return this.destroyAsync();

                     case 5:
                     case 'end':
                        return _context3.stop();
                  }
               }
            }, _callee3, this);
         }));

         function _destroyEventbusAsync() {
            return _ref3.apply(this, arguments);
         }

         return _destroyEventbusAsync;
      }()

      /**
       * Returns the enabled state of a plugin.
       *
       * @param {string}   pluginName - Plugin name to set state.
       *
       * @returns {boolean} - Operation success.
       */

   }, {
      key: 'getPluginEnabled',
      value: function getPluginEnabled(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }

         var entry = this._pluginMap.get(pluginName);

         return entry instanceof _PluginEntry2.default && entry.enabled;
      }

      /**
       * Returns the event binding names registered on any associated plugin EventProxy.
       *
       * @param {string}   pluginName - Plugin name to set state.
       *
       * @returns {string[]} - Event binding names registered from the plugin.
       */

   }, {
      key: 'getPluginEventNames',
      value: function getPluginEventNames(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }

         var entry = this._pluginMap.get(pluginName);

         return entry instanceof _PluginEntry2.default && entry._eventProxy ? entry._eventProxy.getEventNames() : [];
      }

      /**
       * Returns the enabled state of a list of plugins.
       *
       * @param {Array<string>}  pluginNames - An array / iterable of plugin names.
       *
       * @returns {Array<{pluginName: string, enabled: boolean}>} A list of objects with plugin name and enabled state.
       */

   }, {
      key: 'getPluginsEnabled',
      value: function getPluginsEnabled(pluginNames) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         var results = [];

         var _iteratorNormalCompletion3 = true;
         var _didIteratorError3 = false;
         var _iteratorError3 = undefined;

         try {
            for (var _iterator3 = (0, _getIterator3.default)(pluginNames), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
               var pluginName = _step3.value;

               results.push({ pluginName: pluginName, enabled: this.getPluginEnabled(pluginName) });
            }
         } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
               }
            } finally {
               if (_didIteratorError3) {
                  throw _iteratorError3;
               }
            }
         }

         return results;
      }

      /**
       * Returns the event binding names registered from each plugin.
       *
       * @param {string|string[]} [nameOrList] - An array / iterable of plugin names.
       *
       * @returns {Array<{pluginName: string, events: string[]}>} A list of objects with plugin name and event binding
       *                                                          names registered from the plugin.
       */

   }, {
      key: 'getPluginsEventNames',
      value: function getPluginsEventNames(nameOrList) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }
         if (typeof nameOrList === 'string') {
            nameOrList = [nameOrList];
         }

         var results = [];

         var _iteratorNormalCompletion4 = true;
         var _didIteratorError4 = false;
         var _iteratorError4 = undefined;

         try {
            for (var _iterator4 = (0, _getIterator3.default)(nameOrList), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
               var pluginName = _step4.value;

               results.push({ pluginName: pluginName, events: this.getPluginEventNames(pluginName) });
            }
         } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
               }
            } finally {
               if (_didIteratorError4) {
                  throw _iteratorError4;
               }
            }
         }

         return results;
      }

      /**
       * Returns the plugin names that registered the given event binding name.
       *
       * @param {string} eventName - An event name that plugins may have registered.
       *
       * @returns {Array<string[]>} A list of plugin names that has registered the given event name.
       */

   }, {
      key: 'getPluginsByEventName',
      value: function getPluginsByEventName(eventName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof eventName !== 'string') {
            throw new TypeError('\'eventName\' is not a \'string\'.');
         }

         var results = [];

         var pluginEventNames = this.getPluginsEventNames();

         var _iteratorNormalCompletion5 = true;
         var _didIteratorError5 = false;
         var _iteratorError5 = undefined;

         try {
            for (var _iterator5 = (0, _getIterator3.default)(pluginEventNames), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
               var entry = _step5.value;

               if (entry.events.indexOf(eventName) >= 0) {
                  results.push(entry.pluginName);
               }
            }
         } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
               }
            } finally {
               if (_didIteratorError5) {
                  throw _iteratorError5;
               }
            }
         }

         return results;
      }

      /**
       * Returns all plugin data or if a boolean is passed in will return plugin data by current enabled state.
       *
       * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.
       *
       * @returns {Array<PluginData>}
       */

   }, {
      key: 'getAllPluginData',
      value: function getAllPluginData() {
         var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined') {
            throw new TypeError('\'enabled\' is not a \'boolean\' or \'undefined\'.');
         }

         var results = [];

         // Return all plugin data if enabled is not defined.
         var allPlugins = typeof enabled === 'undefined';

         var _iteratorNormalCompletion6 = true;
         var _didIteratorError6 = false;
         var _iteratorError6 = undefined;

         try {
            for (var _iterator6 = (0, _getIterator3.default)(this._pluginMap.values()), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
               var entry = _step6.value;

               if (allPlugins || entry.enabled === enabled) {
                  results.push(this.getPluginData(entry.name));
               }
            }
         } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
               }
            } finally {
               if (_didIteratorError6) {
                  throw _iteratorError6;
               }
            }
         }

         return results;
      }

      /**
       * Returns any associated eventbus.
       *
       * @returns {TyphonEvents|null}
       */

   }, {
      key: 'getEventbus',
      value: function getEventbus() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         return this._eventbus;
      }

      /**
       * Returns any extra event data associated with PluginEvents.
       *
       * @returns {*}
       */

   }, {
      key: 'getExtraEventData',
      value: function getExtraEventData() {
         return this._extraEventData;
      }

      /**
       * Returns all method names or if a boolean is passed in will return method names for plugins by current enabled
       * state.
       *
       * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugin methods names given their
       *                                      enabled state.
       *
       * @param {string|undefined}  pluginName - If a string then just this plugins methods names are returned.
       *
       * @returns {Array<string>}
       */

   }, {
      key: 'getMethodNames',
      value: function getMethodNames() {
         var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
         var pluginName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined') {
            throw new TypeError('\'enabled\' is not a \'boolean\' or \'undefined\'.');
         }

         var results = {};
         var allEnabled = typeof enabled === 'undefined';
         var allNames = typeof pluginName === 'undefined';

         var _iteratorNormalCompletion7 = true;
         var _didIteratorError7 = false;
         var _iteratorError7 = undefined;

         try {
            for (var _iterator7 = (0, _getIterator3.default)(this._pluginMap.values()), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
               var entry = _step7.value;

               if (entry.instance && (allEnabled || entry.enabled === enabled) && (allNames || entry.name === pluginName)) {
                  var _iteratorNormalCompletion8 = true;
                  var _didIteratorError8 = false;
                  var _iteratorError8 = undefined;

                  try {
                     for (var _iterator8 = (0, _getIterator3.default)(s_GET_ALL_PROPERTY_NAMES(entry.instance)), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                        var name = _step8.value;

                        // Skip any names that are not a function or are the constructor.
                        if (entry.instance[name] instanceof Function && name !== 'constructor') {
                           results[name] = true;
                        }
                     }
                  } catch (err) {
                     _didIteratorError8 = true;
                     _iteratorError8 = err;
                  } finally {
                     try {
                        if (!_iteratorNormalCompletion8 && _iterator8.return) {
                           _iterator8.return();
                        }
                     } finally {
                        if (_didIteratorError8) {
                           throw _iteratorError8;
                        }
                     }
                  }
               }
            }
         } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
               }
            } finally {
               if (_didIteratorError7) {
                  throw _iteratorError7;
               }
            }
         }

         return (0, _keys2.default)(results);
      }

      /**
       * Returns a copy of the plugin manager options.
       *
       * @returns {PluginManagerOptions}
       */

   }, {
      key: 'getOptions',
      value: function getOptions() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         return JSON.parse((0, _stringify2.default)(this._options));
      }

      /**
       * Gets the plugin data for a plugin by name.
       *
       * @param {string}   pluginName - A plugin name.
       *
       * @returns {PluginData|undefined}
       */

   }, {
      key: 'getPluginData',
      value: function getPluginData(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }

         var entry = this._pluginMap.get(pluginName);

         if (entry instanceof _PluginEntry2.default) {
            return JSON.parse((0, _stringify2.default)(entry.data));
         }

         return void 0;
      }

      /**
       * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.
       *
       * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.
       *
       * @returns {Array<{plugin: string, method: string}>}
       */

   }, {
      key: 'getPluginMethodNames',
      value: function getPluginMethodNames() {
         var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined') {
            throw new TypeError('\'enabled\' is not a \'boolean\' or \'undefined\'.');
         }

         var results = [];
         var allPlugins = typeof enabled === 'undefined';

         var _iteratorNormalCompletion9 = true;
         var _didIteratorError9 = false;
         var _iteratorError9 = undefined;

         try {
            for (var _iterator9 = (0, _getIterator3.default)(this._pluginMap.values()), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
               var entry = _step9.value;

               if (entry.instance && (allPlugins || entry.enabled === enabled)) {
                  var _iteratorNormalCompletion10 = true;
                  var _didIteratorError10 = false;
                  var _iteratorError10 = undefined;

                  try {
                     for (var _iterator10 = (0, _getIterator3.default)(s_GET_ALL_PROPERTY_NAMES(entry.instance)), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                        var name = _step10.value;

                        // Skip any names that are not a function or are the constructor.
                        if (entry.instance[name] instanceof Function && name !== 'constructor') {
                           results.push({ plugin: entry.name, method: name });
                        }
                     }
                  } catch (err) {
                     _didIteratorError10 = true;
                     _iteratorError10 = err;
                  } finally {
                     try {
                        if (!_iteratorNormalCompletion10 && _iterator10.return) {
                           _iterator10.return();
                        }
                     } finally {
                        if (_didIteratorError10) {
                           throw _iteratorError10;
                        }
                     }
                  }
               }
            }
         } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion9 && _iterator9.return) {
                  _iterator9.return();
               }
            } finally {
               if (_didIteratorError9) {
                  throw _iteratorError9;
               }
            }
         }

         return results;
      }

      /**
       * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.
       *
       * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.
       *
       * @returns {Array<string>}
       */

   }, {
      key: 'getPluginNames',
      value: function getPluginNames() {
         var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined') {
            throw new TypeError('\'enabled\' is not a \'boolean\' or \'undefined\'.');
         }

         // Return all plugin names if enabled is not defined.
         if (enabled === void 0) {
            return (0, _from2.default)(this._pluginMap.keys());
         }

         var results = [];

         var _iteratorNormalCompletion11 = true;
         var _didIteratorError11 = false;
         var _iteratorError11 = undefined;

         try {
            for (var _iterator11 = (0, _getIterator3.default)(this._pluginMap.values()), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
               var entry = _step11.value;

               if (entry.enabled === enabled) {
                  results.push(entry.name);
               }
            }
         } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion11 && _iterator11.return) {
                  _iterator11.return();
               }
            } finally {
               if (_didIteratorError11) {
                  throw _iteratorError11;
               }
            }
         }

         return results;
      }

      /**
       * Returns a copy of the given plugin options.
       *
       * @param {string}   pluginName - Plugin name to retrieve.
       *
       * @returns {*}
       */

   }, {
      key: 'getPluginOptions',
      value: function getPluginOptions(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }

         var result = void 0;

         var entry = this._pluginMap.get(pluginName);

         if (entry instanceof _PluginEntry2.default) {
            result = JSON.parse((0, _stringify2.default)(entry.data.plugin.options));
         }

         return result;
      }

      /**
       * Returns true if there is at least one plugin loaded with the given method name.
       *
       * @param {string}   methodName - Method name to test.
       *
       * @returns {boolean} - True method is found.
       */

   }, {
      key: 'hasMethod',
      value: function hasMethod(methodName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof methodName !== 'string') {
            throw new TypeError('\'methodName\' is not a string.');
         }

         var _iteratorNormalCompletion12 = true;
         var _didIteratorError12 = false;
         var _iteratorError12 = undefined;

         try {
            for (var _iterator12 = (0, _getIterator3.default)(this._pluginMap.values()), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
               var plugin = _step12.value;

               if (typeof plugin.instance[methodName] === 'function') {
                  return true;
               }
            }
         } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion12 && _iterator12.return) {
                  _iterator12.return();
               }
            } finally {
               if (_didIteratorError12) {
                  throw _iteratorError12;
               }
            }
         }

         return false;
      }

      /**
       * Returns true if there is a plugin loaded with the given plugin name.
       *
       * @param {string}   pluginName - Plugin name to test.
       *
       * @returns {boolean} - True if a plugin exists.
       */

   }, {
      key: 'hasPlugin',
      value: function hasPlugin(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }

         return this._pluginMap.has(pluginName);
      }

      /**
       * Returns true if there is a plugin loaded with the given plugin name that also has a method with the given
       * method name.
       *
       * @param {string}   pluginName - Plugin name to test.
       * @param {string}   methodName - Method name to test.
       *
       * @returns {boolean} - True if a plugin and method exists.
       */

   }, {
      key: 'hasPluginMethod',
      value: function hasPluginMethod(pluginName, methodName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }
         if (typeof methodName !== 'string') {
            throw new TypeError('\'methodName\' is not a string.');
         }

         var plugin = this._pluginMap.get(pluginName);

         return plugin instanceof _PluginEntry2.default && typeof plugin[methodName] === 'function';
      }

      /**
       * This dispatch method simply invokes any plugin targets for the given methodName..
       *
       * @param {string}               methodName - Method name to invoke.
       *
       * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.
       *
       * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to
       *                                              invoke.
       */

   }, {
      key: 'invoke',
      value: function invoke(methodName) {
         var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
         var nameOrList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof methodName !== 'string') {
            throw new TypeError('\'methodName\' is not a string.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }

         if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) && typeof nameOrList[_iterator26.default] !== 'function') {
            throw new TypeError('\'nameOrList\' is not a string, array, or iterator.');
         }

         // Track if a plugin method is invoked.
         var hasMethod = false;
         var hasPlugin = false;

         // Early out if plugins are not enabled.
         if (!this._options.pluginsEnabled) {
            return;
         }

         if (typeof nameOrList === 'string') {
            var plugin = this._pluginMap.get(nameOrList);

            if (plugin instanceof _PluginEntry2.default && plugin.enabled && plugin.instance) {
               hasPlugin = true;

               if (typeof plugin.instance[methodName] === 'function') {
                  var _plugin$instance;

                  Array.isArray(args) ? (_plugin$instance = plugin.instance)[methodName].apply(_plugin$instance, (0, _toConsumableArray3.default)(args)) : plugin.instance[methodName](args);

                  hasMethod = true;
               }
            }
         } else {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
               for (var _iterator13 = (0, _getIterator3.default)(nameOrList), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                  var name = _step13.value;

                  var _plugin = this._pluginMap.get(name);

                  if (_plugin instanceof _PluginEntry2.default && _plugin.enabled && _plugin.instance) {
                     hasPlugin = true;

                     if (typeof _plugin.instance[methodName] === 'function') {
                        var _plugin$instance2;

                        Array.isArray(args) ? (_plugin$instance2 = _plugin.instance)[methodName].apply(_plugin$instance2, (0, _toConsumableArray3.default)(args)) : _plugin.instance[methodName](args);

                        hasMethod = true;
                     }
                  }
               }
            } catch (err) {
               _didIteratorError13 = true;
               _iteratorError13 = err;
            } finally {
               try {
                  if (!_iteratorNormalCompletion13 && _iterator13.return) {
                     _iterator13.return();
                  }
               } finally {
                  if (_didIteratorError13) {
                     throw _iteratorError13;
                  }
               }
            }
         }

         if (this._options.throwNoPlugin && !hasPlugin) {
            throw new Error('PluginManager failed to find any target plugins.');
         }

         if (this._options.throwNoMethod && !hasMethod) {
            throw new Error('PluginManager failed to invoke \'' + methodName + '\'.');
         }
      }

      /**
       * This dispatch method uses ES6 Promises and adds any returned results to an array which is added to a Promise.all
       * construction which passes back a Promise which waits until all Promises complete. Any target invoked may return a
       * Promise or any result. This is very useful to use for any asynchronous operations.
       *
       * @param {string}               methodName - Method name to invoke.
       *
       * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.
       *
       * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to
       *                                              invoke.
       *
       * @returns {Promise<*|Array<*>>}
       */

   }, {
      key: 'invokeAsync',
      value: function invokeAsync(methodName) {
         var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
         var nameOrList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof methodName !== 'string') {
            throw new TypeError('\'methodName\' is not a string.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }

         if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) && typeof nameOrList[_iterator26.default] !== 'function') {
            throw new TypeError('\'nameOrList\' is not a string, array, or iterator.');
         }

         // Track if a plugin method is invoked.
         var hasMethod = false;
         var hasPlugin = false;

         // Capture results.
         var result = void 0;
         var results = [];

         // Early out if plugins are not enabled.
         if (!this._options.pluginsEnabled) {
            return result;
         }

         try {
            if (typeof nameOrList === 'string') {
               var plugin = this._pluginMap.get(nameOrList);

               if (plugin instanceof _PluginEntry2.default && plugin.enabled && plugin.instance) {
                  hasPlugin = true;

                  if (typeof plugin.instance[methodName] === 'function') {
                     var _plugin$instance3;

                     result = Array.isArray(args) ? (_plugin$instance3 = plugin.instance)[methodName].apply(_plugin$instance3, (0, _toConsumableArray3.default)(args)) : plugin.instance[methodName](args);

                     // If we received a valid result return immediately.
                     if (result !== null || typeof result !== 'undefined') {
                        results.push(result);
                     }

                     hasMethod = true;
                  }
               }
            } else {
               var _iteratorNormalCompletion14 = true;
               var _didIteratorError14 = false;
               var _iteratorError14 = undefined;

               try {
                  for (var _iterator14 = (0, _getIterator3.default)(nameOrList), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                     var name = _step14.value;

                     var _plugin2 = this._pluginMap.get(name);

                     if (_plugin2 instanceof _PluginEntry2.default && _plugin2.enabled && _plugin2.instance) {
                        hasPlugin = true;

                        if (typeof _plugin2.instance[methodName] === 'function') {
                           var _plugin2$instance;

                           result = Array.isArray(args) ? (_plugin2$instance = _plugin2.instance)[methodName].apply(_plugin2$instance, (0, _toConsumableArray3.default)(args)) : _plugin2.instance[methodName](args);

                           // If we received a valid result return immediately.
                           if (result !== null || typeof result !== 'undefined') {
                              results.push(result);
                           }

                           hasMethod = true;
                        }
                     }
                  }
               } catch (err) {
                  _didIteratorError14 = true;
                  _iteratorError14 = err;
               } finally {
                  try {
                     if (!_iteratorNormalCompletion14 && _iterator14.return) {
                        _iterator14.return();
                     }
                  } finally {
                     if (_didIteratorError14) {
                        throw _iteratorError14;
                     }
                  }
               }
            }

            if (this._options.throwNoPlugin && !hasPlugin) {
               return _promise2.default.reject(new Error('PluginManager failed to find any target plugins.'));
            }

            if (this._options.throwNoMethod && !hasMethod) {
               return _promise2.default.reject(new Error('PluginManager failed to invoke \'' + methodName + '\'.'));
            }
         } catch (error) {
            return _promise2.default.reject(error);
         }

         // If there are multiple results then use Promise.all otherwise Promise.resolve.
         return results.length > 1 ? _promise2.default.all(results) : _promise2.default.resolve(result);
      }

      /**
       * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.
       *
       * @param {string}               methodName - Method name to invoke.
       *
       * @param {object}               [copyProps={}] - plugin event object.
       *
       * @param {object}               [passthruProps={}] - if true, event has plugin option.
       *
       * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to
       *                                              invoke.
       *
       * @returns {Promise<PluginEvent>}
       */

   }, {
      key: 'invokeAsyncEvent',
      value: function invokeAsyncEvent(methodName) {
         var copyProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
         var passthruProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
         var nameOrList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }

         // Early out if plugins are not enabled.
         if (!this._options.pluginsEnabled) {
            return _promise2.default.resolve();
         }

         // Invokes the private internal async events method with optional error checking enabled.
         return s_INVOKE_ASYNC_EVENTS(methodName, copyProps, passthruProps, this._extraEventData, nameOrList, this._pluginMap, this._options);
      }

      /**
       * This dispatch method synchronously passes back a single value or an array with all results returned by any
       * invoked targets.
       *
       * @param {string}               methodName - Method name to invoke.
       *
       * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.
       *
       * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to
       *                                              invoke.
       *
       * @returns {*|Array<*>}
       */

   }, {
      key: 'invokeSync',
      value: function invokeSync(methodName) {
         var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;
         var nameOrList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof methodName !== 'string') {
            throw new TypeError('\'methodName\' is not a string.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }

         if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) && typeof nameOrList[_iterator26.default] !== 'function') {
            throw new TypeError('\'nameOrList\' is not a string, array, or iterator.');
         }

         // Track if a plugin method is invoked.
         var hasMethod = false;
         var hasPlugin = false;

         // Capture results.
         var result = void 0;
         var results = [];

         // Early out if plugins are not enabled.
         if (!this._options.pluginsEnabled) {
            return result;
         }

         if (typeof nameOrList === 'string') {
            var plugin = this._pluginMap.get(nameOrList);

            if (plugin instanceof _PluginEntry2.default && plugin.enabled && plugin.instance) {
               hasPlugin = true;

               if (typeof plugin.instance[methodName] === 'function') {
                  var _plugin$instance4;

                  result = Array.isArray(args) ? (_plugin$instance4 = plugin.instance)[methodName].apply(_plugin$instance4, (0, _toConsumableArray3.default)(args)) : plugin.instance[methodName](args);

                  // If we received a valid result return immediately.
                  if (result !== null || typeof result !== 'undefined') {
                     results.push(result);
                  }

                  hasMethod = true;
               }
            }
         } else {
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
               for (var _iterator15 = (0, _getIterator3.default)(nameOrList), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                  var name = _step15.value;

                  var _plugin3 = this._pluginMap.get(name);

                  if (_plugin3 instanceof _PluginEntry2.default && _plugin3.enabled && _plugin3.instance) {
                     hasPlugin = true;

                     if (typeof _plugin3.instance[methodName] === 'function') {
                        var _plugin3$instance;

                        result = Array.isArray(args) ? (_plugin3$instance = _plugin3.instance)[methodName].apply(_plugin3$instance, (0, _toConsumableArray3.default)(args)) : _plugin3.instance[methodName](args);

                        // If we received a valid result return immediately.
                        if (result !== null || typeof result !== 'undefined') {
                           results.push(result);
                        }

                        hasMethod = true;
                     }
                  }
               }
            } catch (err) {
               _didIteratorError15 = true;
               _iteratorError15 = err;
            } finally {
               try {
                  if (!_iteratorNormalCompletion15 && _iterator15.return) {
                     _iterator15.return();
                  }
               } finally {
                  if (_didIteratorError15) {
                     throw _iteratorError15;
                  }
               }
            }
         }

         if (this._options.throwNoPlugin && !hasPlugin) {
            throw new Error('PluginManager failed to find any target plugins.');
         }

         if (this._options.throwNoMethod && !hasMethod) {
            throw new Error('PluginManager failed to invoke \'' + methodName + '\'.');
         }

         // Return the results array if there are more than one or just a single result.
         return results.length > 1 ? results : result;
      }

      /**
       * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.
       *
       * @param {string}               methodName - Method name to invoke.
       *
       * @param {object}               [copyProps={}] - plugin event object.
       *
       * @param {object}               [passthruProps={}] - if true, event has plugin option.
       *
       * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to
       *                                              invoke.
       *
       * @returns {PluginEvent|undefined}
       */

   }, {
      key: 'invokeSyncEvent',
      value: function invokeSyncEvent(methodName) {
         var copyProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
         var passthruProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
         var nameOrList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof nameOrList === 'undefined') {
            nameOrList = this._pluginMap.keys();
         }

         // Early out if plugins are not enabled.
         if (!this._options.pluginsEnabled) {
            return void 0;
         }

         // Invokes the private internal sync events method with optional error checking enabled.
         return s_INVOKE_SYNC_EVENTS(methodName, copyProps, passthruProps, this._extraEventData, nameOrList, this._pluginMap, this._options);
      }

      /**
       * Performs validation of a PluginConfig.
       *
       * @param {PluginConfig}   pluginConfig - A PluginConfig to validate.
       *
       * @returns {boolean} True if the given PluginConfig is valid.
       */

   }, {
      key: 'isValidConfig',
      value: function isValidConfig(pluginConfig) {
         if ((typeof pluginConfig === 'undefined' ? 'undefined' : (0, _typeof3.default)(pluginConfig)) !== 'object') {
            return false;
         }

         if (typeof pluginConfig.name !== 'string') {
            return false;
         }

         if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string') {
            return false;
         }

         if (typeof pluginConfig.options !== 'undefined' && (0, _typeof3.default)(pluginConfig.options) !== 'object') {
            return false;
         }

         return true;
      }

      /**
       * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager
       * events will be removed then added to the new eventbus. If there are any existing plugins being managed their
       * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.
       *
       * @param {TyphonEvents}   targetEventbus - The target eventbus to associate.
       *
       * @param {string}         [eventPrepend='plugins'] - An optional string to prepend to all of the event binding
       *                                                    targets.
       *
       * @returns {PluginManager}
       */

   }, {
      key: 'setEventbus',
      value: function setEventbus(targetEventbus) {
         var eventPrepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'plugins';

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if ((typeof targetEventbus === 'undefined' ? 'undefined' : (0, _typeof3.default)(targetEventbus)) !== 'object') {
            throw new TypeError('\'targetEventbus\' is not an \'object\'.');
         }
         if (typeof eventPrepend !== 'string') {
            throw new TypeError('\'eventPrepend\' is not a \'string\'.');
         }

         // Early escape if the targetEventbus is the same as the current eventbus.
         if (targetEventbus === this._eventbus) {
            return this;
         }

         var oldPrepend = this._eventPrepend;

         /**
          * Stores the prepend string for eventbus registration.
          * @type {string}
          * @private
          */
         this._eventPrepend = eventPrepend;

         // Unload and reload any existing plugins from the old eventbus to the target eventbus.
         if (this._pluginMap.size > 0) {
            // Invoke private module method which allows skipping optional error checking.
            s_INVOKE_SYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, this._pluginMap.keys(), this._pluginMap, this._options, false);

            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
               for (var _iterator16 = (0, _getIterator3.default)(this._pluginMap.values()), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  var entry = _step16.value;

                  // Automatically remove any potential reference to a stored event proxy instance.
                  try {
                     entry.instance._eventbus = void 0;
                  } catch (err) {/* nop */}

                  entry.data.manager.eventPrepend = eventPrepend;
                  entry.data.plugin.scopedName = eventPrepend + ':' + entry.name;

                  if (entry.eventProxy instanceof _EventProxy2.default) {
                     entry.eventProxy.destroy();
                  }

                  entry.eventProxy = new _EventProxy2.default(targetEventbus);
               }

               // Invoke private module method which allows skipping optional error checking.
            } catch (err) {
               _didIteratorError16 = true;
               _iteratorError16 = err;
            } finally {
               try {
                  if (!_iteratorNormalCompletion16 && _iterator16.return) {
                     _iterator16.return();
                  }
               } finally {
                  if (_didIteratorError16) {
                     throw _iteratorError16;
                  }
               }
            }

            s_INVOKE_SYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, this._pluginMap.keys(), this._pluginMap, this._options, false);

            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
               for (var _iterator17 = (0, _getIterator3.default)(this._pluginMap.values()), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                  var _entry = _step17.value;

                  // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin
                  // changing eventbus.
                  if (this._eventbus) {
                     this._eventbus.trigger('typhonjs:plugin:manager:eventbus:changed', (0, _assign2.default)({
                        oldEventbus: this._eventbus,
                        oldManagerEventPrepend: oldPrepend,
                        oldScopedName: oldPrepend + ':' + _entry.name,
                        newEventbus: targetEventbus,
                        newManagerEventPrepend: eventPrepend,
                        newScopedName: eventPrepend + ':' + _entry.name
                     }, JSON.parse((0, _stringify2.default)(_entry.data))));
                  }
               }
            } catch (err) {
               _didIteratorError17 = true;
               _iteratorError17 = err;
            } finally {
               try {
                  if (!_iteratorNormalCompletion17 && _iterator17.return) {
                     _iterator17.return();
                  }
               } finally {
                  if (_didIteratorError17) {
                     throw _iteratorError17;
                  }
               }
            }
         }

         if (this._eventbus !== null) {
            this._eventbus.off(oldPrepend + ':add', this._addEventbus, this);
            this._eventbus.off(oldPrepend + ':add:all', this._addAllEventbus, this);
            this._eventbus.off(oldPrepend + ':async:add', this._addEventbusAsync, this);
            this._eventbus.off(oldPrepend + ':async:add:all', this._addAllEventbusAsync, this);
            this._eventbus.off(oldPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
            this._eventbus.off(oldPrepend + ':async:invoke', this.invokeAsync, this);
            this._eventbus.off(oldPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
            this._eventbus.off(oldPrepend + ':async:remove', this._removeEventbusAsync, this);
            this._eventbus.off(oldPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
            this._eventbus.off(oldPrepend + ':create:event:proxy', this.createEventProxy, this);
            this._eventbus.off(oldPrepend + ':destroy:manager', this._destroyEventbus, this);
            this._eventbus.off(oldPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
            this._eventbus.off(oldPrepend + ':get:extra:event:data', this.getExtraEventData, this);
            this._eventbus.off(oldPrepend + ':get:method:names', this.getMethodNames, this);
            this._eventbus.off(oldPrepend + ':get:options', this.getOptions, this);
            this._eventbus.off(oldPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
            this._eventbus.off(oldPrepend + ':get:plugin:data', this.getPluginData, this);
            this._eventbus.off(oldPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
            this._eventbus.off(oldPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
            this._eventbus.off(oldPrepend + ':get:plugin:names', this.getPluginNames, this);
            this._eventbus.off(oldPrepend + ':get:plugin:options', this.getPluginOptions, this);
            this._eventbus.off(oldPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
            this._eventbus.off(oldPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
            this._eventbus.off(oldPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
            this._eventbus.off(oldPrepend + ':has:method', this.hasMethod, this);
            this._eventbus.off(oldPrepend + ':has:plugin', this.hasPlugin, this);
            this._eventbus.off(oldPrepend + ':has:plugin:method', this.hasPluginMethod, this);
            this._eventbus.off(oldPrepend + ':invoke', this.invoke, this);
            this._eventbus.off(oldPrepend + ':is:valid:config', this.isValidConfig, this);
            this._eventbus.off(oldPrepend + ':remove', this._removeEventbus, this);
            this._eventbus.off(oldPrepend + ':remove:all', this._removeAllEventbus, this);
            this._eventbus.off(oldPrepend + ':set:extra:event:data', this.setExtraEventData, this);
            this._eventbus.off(oldPrepend + ':set:options', this._setOptionsEventbus, this);
            this._eventbus.off(oldPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
            this._eventbus.off(oldPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
            this._eventbus.off(oldPrepend + ':sync:invoke', this.invokeSync, this);
            this._eventbus.off(oldPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);

            // Invoke `typhonjs:plugin:manager:eventbus:removed` allowing external code to react to eventbus removal.
            this._eventbus.trigger('typhonjs:plugin:manager:eventbus:removed', {
               oldEventbus: this._eventbus,
               oldEventPrepend: oldPrepend,
               newEventbus: targetEventbus,
               newEventPrepend: eventPrepend
            });
         }

         targetEventbus.on(eventPrepend + ':add', this._addEventbus, this);
         targetEventbus.on(eventPrepend + ':add:all', this._addAllEventbus, this);
         targetEventbus.on(eventPrepend + ':async:add', this._addEventbusAsync, this);
         targetEventbus.on(eventPrepend + ':async:add:all', this._addAllEventbusAsync, this);
         targetEventbus.on(eventPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
         targetEventbus.on(eventPrepend + ':async:invoke', this.invokeAsync, this);
         targetEventbus.on(eventPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
         targetEventbus.on(eventPrepend + ':async:remove', this._removeEventbusAsync, this);
         targetEventbus.on(eventPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
         targetEventbus.on(eventPrepend + ':create:event:proxy', this.createEventProxy, this);
         targetEventbus.on(eventPrepend + ':destroy:manager', this._destroyEventbus, this);
         targetEventbus.on(eventPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
         targetEventbus.on(eventPrepend + ':get:extra:event:data', this.getExtraEventData, this);
         targetEventbus.on(eventPrepend + ':get:method:names', this.getMethodNames, this);
         targetEventbus.on(eventPrepend + ':get:options', this.getOptions, this);
         targetEventbus.on(eventPrepend + ':get:plugin:data', this.getPluginData, this);
         targetEventbus.on(eventPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
         targetEventbus.on(eventPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
         targetEventbus.on(eventPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
         targetEventbus.on(eventPrepend + ':get:plugin:names', this.getPluginNames, this);
         targetEventbus.on(eventPrepend + ':get:plugin:options', this.getPluginOptions, this);
         targetEventbus.on(eventPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
         targetEventbus.on(eventPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
         targetEventbus.on(eventPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
         targetEventbus.on(eventPrepend + ':has:method', this.hasMethod, this);
         targetEventbus.on(eventPrepend + ':has:plugin', this.hasPlugin, this);
         targetEventbus.on(eventPrepend + ':has:plugin:method', this.hasPluginMethod, this);
         targetEventbus.on(eventPrepend + ':invoke', this.invoke, this);
         targetEventbus.on(eventPrepend + ':is:valid:config', this.isValidConfig, this);
         targetEventbus.on(eventPrepend + ':remove', this._removeEventbus, this);
         targetEventbus.on(eventPrepend + ':remove:all', this._removeAllEventbus, this);
         targetEventbus.on(eventPrepend + ':set:extra:event:data', this.setExtraEventData, this);
         targetEventbus.on(eventPrepend + ':set:options', this._setOptionsEventbus, this);
         targetEventbus.on(eventPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
         targetEventbus.on(eventPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
         targetEventbus.on(eventPrepend + ':sync:invoke', this.invokeSync, this);
         targetEventbus.on(eventPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);

         // Invoke `typhonjs:plugin:manager:eventbus:set` allowing external code to react to eventbus set.
         targetEventbus.trigger('typhonjs:plugin:manager:eventbus:set', {
            oldEventbus: this._eventbus,
            oldEventPrepend: oldPrepend,
            newEventbus: targetEventbus,
            newEventPrepend: eventPrepend
         });

         this._eventbus = targetEventbus;

         return this;
      }

      /**
       * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager
       * events will be removed then added to the new eventbus. If there are any existing plugins being managed their
       * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.
       *
       * @param {TyphonEvents}   targetEventbus - The target eventbus to associate.
       *
       * @param {string}         [eventPrepend='plugins'] - An optional string to prepend to all of the event binding
       *                                                    targets.
       *
       * @returns {Promise<PluginManager>}
       */

   }, {
      key: 'setEventbusAsync',
      value: function () {
         var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(targetEventbus) {
            var eventPrepend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'plugins';

            var oldPrepend, _iteratorNormalCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step18, entry, _iteratorNormalCompletion19, _didIteratorError19, _iteratorError19, _iterator19, _step19, _entry2;

            return _regenerator2.default.wrap(function _callee4$(_context4) {
               while (1) {
                  switch (_context4.prev = _context4.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context4.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        if (!((typeof targetEventbus === 'undefined' ? 'undefined' : (0, _typeof3.default)(targetEventbus)) !== 'object')) {
                           _context4.next = 4;
                           break;
                        }

                        throw new TypeError('\'targetEventbus\' is not an \'object\'.');

                     case 4:
                        if (!(typeof eventPrepend !== 'string')) {
                           _context4.next = 6;
                           break;
                        }

                        throw new TypeError('\'eventPrepend\' is not a \'string\'.');

                     case 6:
                        if (!(targetEventbus === this._eventbus)) {
                           _context4.next = 8;
                           break;
                        }

                        return _context4.abrupt('return', this);

                     case 8:
                        oldPrepend = this._eventPrepend;

                        /**
                         * Stores the prepend string for eventbus registration.
                         * @type {string}
                         * @private
                         */

                        this._eventPrepend = eventPrepend;

                        // Unload and reload any existing plugins from the old eventbus to the target eventbus.

                        if (!(this._pluginMap.size > 0)) {
                           _context4.next = 53;
                           break;
                        }

                        _context4.next = 13;
                        return s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, this._pluginMap.keys(), this._pluginMap, this._options, false);

                     case 13:
                        _iteratorNormalCompletion18 = true;
                        _didIteratorError18 = false;
                        _iteratorError18 = undefined;
                        _context4.prev = 16;


                        for (_iterator18 = (0, _getIterator3.default)(this._pluginMap.values()); !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                           entry = _step18.value;

                           // Automatically remove any potential reference to a stored event proxy instance.
                           try {
                              entry.instance._eventbus = void 0;
                           } catch (err) {/* nop */}

                           entry.data.manager.eventPrepend = eventPrepend;
                           entry.data.plugin.scopedName = eventPrepend + ':' + entry.name;

                           if (entry.eventProxy instanceof _EventProxy2.default) {
                              entry.eventProxy.destroy();
                           }

                           entry.eventProxy = new _EventProxy2.default(targetEventbus);
                        }

                        // Invoke private module method which allows skipping optional error checking.
                        _context4.next = 24;
                        break;

                     case 20:
                        _context4.prev = 20;
                        _context4.t0 = _context4['catch'](16);
                        _didIteratorError18 = true;
                        _iteratorError18 = _context4.t0;

                     case 24:
                        _context4.prev = 24;
                        _context4.prev = 25;

                        if (!_iteratorNormalCompletion18 && _iterator18.return) {
                           _iterator18.return();
                        }

                     case 27:
                        _context4.prev = 27;

                        if (!_didIteratorError18) {
                           _context4.next = 30;
                           break;
                        }

                        throw _iteratorError18;

                     case 30:
                        return _context4.finish(27);

                     case 31:
                        return _context4.finish(24);

                     case 32:
                        _context4.next = 34;
                        return s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, this._pluginMap.keys(), this._pluginMap, this._options, false);

                     case 34:
                        _iteratorNormalCompletion19 = true;
                        _didIteratorError19 = false;
                        _iteratorError19 = undefined;
                        _context4.prev = 37;


                        for (_iterator19 = (0, _getIterator3.default)(this._pluginMap.values()); !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                           _entry2 = _step19.value;

                           // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin
                           // changing eventbus.
                           if (this._eventbus) {
                              this._eventbus.trigger('typhonjs:plugin:manager:eventbus:changed', (0, _assign2.default)({
                                 oldEventbus: this._eventbus,
                                 oldManagerEventPrepend: oldPrepend,
                                 oldScopedName: oldPrepend + ':' + _entry2.name,
                                 newEventbus: targetEventbus,
                                 newManagerEventPrepend: eventPrepend,
                                 newScopedName: eventPrepend + ':' + _entry2.name
                              }, JSON.parse((0, _stringify2.default)(_entry2.data))));
                           }
                        }
                        _context4.next = 45;
                        break;

                     case 41:
                        _context4.prev = 41;
                        _context4.t1 = _context4['catch'](37);
                        _didIteratorError19 = true;
                        _iteratorError19 = _context4.t1;

                     case 45:
                        _context4.prev = 45;
                        _context4.prev = 46;

                        if (!_iteratorNormalCompletion19 && _iterator19.return) {
                           _iterator19.return();
                        }

                     case 48:
                        _context4.prev = 48;

                        if (!_didIteratorError19) {
                           _context4.next = 51;
                           break;
                        }

                        throw _iteratorError19;

                     case 51:
                        return _context4.finish(48);

                     case 52:
                        return _context4.finish(45);

                     case 53:

                        if (this._eventbus !== null) {
                           this._eventbus.off(oldPrepend + ':add', this._addEventbus, this);
                           this._eventbus.off(oldPrepend + ':add:all', this._addAllEventbus, this);
                           this._eventbus.off(oldPrepend + ':async:add', this._addEventbusAsync, this);
                           this._eventbus.off(oldPrepend + ':async:add:all', this._addAllEventbusAsync, this);
                           this._eventbus.off(oldPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
                           this._eventbus.off(oldPrepend + ':async:invoke', this.invokeAsync, this);
                           this._eventbus.off(oldPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
                           this._eventbus.off(oldPrepend + ':async:remove', this._removeEventbusAsync, this);
                           this._eventbus.off(oldPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
                           this._eventbus.off(oldPrepend + ':create:event:proxy', this.createEventProxy, this);
                           this._eventbus.off(oldPrepend + ':destroy:manager', this._destroyEventbus, this);
                           this._eventbus.off(oldPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
                           this._eventbus.off(oldPrepend + ':get:extra:event:data', this.getExtraEventData, this);
                           this._eventbus.off(oldPrepend + ':get:method:names', this.getMethodNames, this);
                           this._eventbus.off(oldPrepend + ':get:options', this.getOptions, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:data', this.getPluginData, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:names', this.getPluginNames, this);
                           this._eventbus.off(oldPrepend + ':get:plugin:options', this.getPluginOptions, this);
                           this._eventbus.off(oldPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
                           this._eventbus.off(oldPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
                           this._eventbus.off(oldPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
                           this._eventbus.off(oldPrepend + ':has:method', this.hasMethod, this);
                           this._eventbus.off(oldPrepend + ':has:plugin', this.hasPlugin, this);
                           this._eventbus.off(oldPrepend + ':has:plugin:method', this.hasPluginMethod, this);
                           this._eventbus.off(oldPrepend + ':invoke', this.invoke, this);
                           this._eventbus.off(oldPrepend + ':is:valid:config', this.isValidConfig, this);
                           this._eventbus.off(oldPrepend + ':remove', this._removeEventbus, this);
                           this._eventbus.off(oldPrepend + ':remove:all', this._removeAllEventbus, this);
                           this._eventbus.off(oldPrepend + ':set:extra:event:data', this.setExtraEventData, this);
                           this._eventbus.off(oldPrepend + ':set:options', this._setOptionsEventbus, this);
                           this._eventbus.off(oldPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
                           this._eventbus.off(oldPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
                           this._eventbus.off(oldPrepend + ':sync:invoke', this.invokeSync, this);
                           this._eventbus.off(oldPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);

                           // Invoke `typhonjs:plugin:manager:eventbus:removed` allowing external code to react to eventbus removal.
                           this._eventbus.trigger('typhonjs:plugin:manager:eventbus:removed', {
                              oldEventbus: this._eventbus,
                              oldEventPrepend: oldPrepend,
                              newEventbus: targetEventbus,
                              newEventPrepend: eventPrepend
                           });
                        }

                        targetEventbus.on(eventPrepend + ':add', this._addEventbus, this);
                        targetEventbus.on(eventPrepend + ':add:all', this._addAllEventbus, this);
                        targetEventbus.on(eventPrepend + ':async:add', this._addEventbusAsync, this);
                        targetEventbus.on(eventPrepend + ':async:add:all', this._addAllEventbusAsync, this);
                        targetEventbus.on(eventPrepend + ':async:destroy:manager', this._destroyEventbusAsync, this);
                        targetEventbus.on(eventPrepend + ':async:invoke', this.invokeAsync, this);
                        targetEventbus.on(eventPrepend + ':async:invoke:event', this.invokeAsyncEvent, this);
                        targetEventbus.on(eventPrepend + ':async:remove', this._removeEventbusAsync, this);
                        targetEventbus.on(eventPrepend + ':async:remove:all', this._removeAllEventbusAsync, this);
                        targetEventbus.on(eventPrepend + ':create:event:proxy', this.createEventProxy, this);
                        targetEventbus.on(eventPrepend + ':destroy:manager', this._destroyEventbus, this);
                        targetEventbus.on(eventPrepend + ':get:all:plugin:data', this.getAllPluginData, this);
                        targetEventbus.on(eventPrepend + ':get:extra:event:data', this.getExtraEventData, this);
                        targetEventbus.on(eventPrepend + ':get:method:names', this.getMethodNames, this);
                        targetEventbus.on(eventPrepend + ':get:options', this.getOptions, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:data', this.getPluginData, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:enabled', this.getPluginEnabled, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:event:names', this.getPluginEventNames, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:method:names', this.getPluginMethodNames, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:names', this.getPluginNames, this);
                        targetEventbus.on(eventPrepend + ':get:plugin:options', this.getPluginOptions, this);
                        targetEventbus.on(eventPrepend + ':get:plugins:enabled', this.getPluginsEnabled, this);
                        targetEventbus.on(eventPrepend + ':get:plugins:by:event:name', this.getPluginsByEventName, this);
                        targetEventbus.on(eventPrepend + ':get:plugins:event:names', this.getPluginsEventNames, this);
                        targetEventbus.on(eventPrepend + ':has:method', this.hasMethod, this);
                        targetEventbus.on(eventPrepend + ':has:plugin', this.hasPlugin, this);
                        targetEventbus.on(eventPrepend + ':has:plugin:method', this.hasPluginMethod, this);
                        targetEventbus.on(eventPrepend + ':invoke', this.invoke, this);
                        targetEventbus.on(eventPrepend + ':is:valid:config', this.isValidConfig, this);
                        targetEventbus.on(eventPrepend + ':remove', this._removeEventbus, this);
                        targetEventbus.on(eventPrepend + ':remove:all', this._removeAllEventbus, this);
                        targetEventbus.on(eventPrepend + ':set:extra:event:data', this.setExtraEventData, this);
                        targetEventbus.on(eventPrepend + ':set:options', this._setOptionsEventbus, this);
                        targetEventbus.on(eventPrepend + ':set:plugin:enabled', this.setPluginEnabled, this);
                        targetEventbus.on(eventPrepend + ':set:plugins:enabled', this.setPluginsEnabled, this);
                        targetEventbus.on(eventPrepend + ':sync:invoke', this.invokeSync, this);
                        targetEventbus.on(eventPrepend + ':sync:invoke:event', this.invokeSyncEvent, this);

                        // Invoke `typhonjs:plugin:manager:eventbus:set` allowing external code to react to eventbus set.
                        targetEventbus.trigger('typhonjs:plugin:manager:eventbus:set', {
                           oldEventbus: this._eventbus,
                           oldEventPrepend: oldPrepend,
                           newEventbus: targetEventbus,
                           newEventPrepend: eventPrepend
                        });

                        this._eventbus = targetEventbus;

                        return _context4.abrupt('return', this);

                     case 94:
                     case 'end':
                        return _context4.stop();
                  }
               }
            }, _callee4, this, [[16, 20, 24, 32], [25,, 27, 31], [37, 41, 45, 53], [46,, 48, 52]]);
         }));

         function setEventbusAsync(_x25) {
            return _ref4.apply(this, arguments);
         }

         return setEventbusAsync;
      }()

      /**
       * Sets any extra event data attached to PluginEvent `extra` field.
       *
       * @param {*}  extraEventData - Adds extra data to PluginEvent `extra` field.
       */

   }, {
      key: 'setExtraEventData',
      value: function setExtraEventData() {
         var extraEventData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         this._extraEventData = extraEventData;
      }

      /**
       * Set optional parameters. All parameters are off by default.
       *
       * @param {PluginManagerOptions} options - Defines optional parameters to set.
       */

   }, {
      key: 'setOptions',
      value: function setOptions() {
         var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if ((typeof options === 'undefined' ? 'undefined' : (0, _typeof3.default)(options)) !== 'object') {
            throw new TypeError('\'options\' is not an object.');
         }

         if (typeof options.pluginsEnabled === 'boolean') {
            this._options.pluginsEnabled = options.pluginsEnabled;
         }
         if (typeof options.noEventAdd === 'boolean') {
            this._options.noEventAdd = options.noEventAdd;
         }
         if (typeof options.noEventDestroy === 'boolean') {
            this._options.noEventDestroy = options.noEventDestroy;
         }
         if (typeof options.noEventOptions === 'boolean') {
            this._options.noEventOptions = options.noEventOptions;
         }
         if (typeof options.noEventRemoval === 'boolean') {
            this._options.noEventRemoval = options.noEventRemoval;
         }
         if (typeof options.throwNoMethod === 'boolean') {
            this._options.throwNoMethod = options.throwNoMethod;
         }
         if (typeof options.throwNoPlugin === 'boolean') {
            this._options.throwNoPlugin = options.throwNoPlugin;
         }
      }

      /**
       * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventOptions` is
       * enabled. This disables the ability for the plugin manager options to be set via events preventing any external
       * code modifying options.
       *
       * @param {PluginManagerOptions} options - Defines optional parameters to set.
       *
       * @private
       */

   }, {
      key: '_setOptionsEventbus',
      value: function _setOptionsEventbus() {
         var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!this._options.noEventOptions) {
            this.setOptions(options);
         }
      }

      /**
       * Enables or disables a single plugin.
       *
       * @param {string}   pluginName - Plugin name to set state.
       * @param {boolean}  enabled - The new enabled state.
       *
       * @returns {boolean} - Operation success.
       */

   }, {
      key: 'setPluginEnabled',
      value: function setPluginEnabled(pluginName, enabled) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof pluginName !== 'string') {
            throw new TypeError('\'pluginName\' is not a string.');
         }
         if (typeof enabled !== 'boolean') {
            throw new TypeError('\'enabled\' is not a boolean.');
         }

         var entry = this._pluginMap.get(pluginName);

         if (entry instanceof _PluginEntry2.default) {
            entry.enabled = enabled;

            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.
            if (this._eventbus) {
               this._eventbus.trigger('typhonjs:plugin:manager:plugin:enabled', (0, _assign2.default)({
                  enabled: enabled
               }, JSON.parse((0, _stringify2.default)(entry.data))));
            }

            return true;
         }

         return false;
      }

      /**
       * Enables or disables a set of plugins given an array or iterabe of plugin names.
       *
       * @param {Array<string>}  pluginNames - An array / iterable of plugin names.
       * @param {boolean}        enabled - The new enabled state.
       *
       * @returns {boolean} - Operation success.
       */

   }, {
      key: 'setPluginsEnabled',
      value: function setPluginsEnabled(pluginNames, enabled) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (typeof enabled !== 'boolean') {
            throw new TypeError('\'enabled\' is not a boolean.');
         }

         var success = true;

         var _iteratorNormalCompletion20 = true;
         var _didIteratorError20 = false;
         var _iteratorError20 = undefined;

         try {
            for (var _iterator20 = (0, _getIterator3.default)(pluginNames), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
               var pluginName = _step20.value;

               if (!this.setPluginEnabled(pluginName, enabled)) {
                  success = false;
               }
            }
         } catch (err) {
            _didIteratorError20 = true;
            _iteratorError20 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion20 && _iterator20.return) {
                  _iterator20.return();
               }
            } finally {
               if (_didIteratorError20) {
                  throw _iteratorError20;
               }
            }
         }

         return success;
      }

      /**
       * Removes a plugin by name after unloading it and clearing any event bindings automatically.
       *
       * @param {string}   pluginName - The plugin name to remove.
       *
       * @returns {boolean} - Operation success.
       */

   }, {
      key: 'remove',
      value: function remove(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         var entry = this._pluginMap.get(pluginName);

         if (entry instanceof _PluginEntry2.default) {
            // Invoke private module method which allows skipping optional error checking.
            s_INVOKE_SYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, pluginName, this._pluginMap, this._options, false);

            // Automatically remove any potential reference to a stored event proxy instance.
            try {
               entry.instance._eventbus = void 0;
            } catch (err) {/* nop */}

            if (entry.eventProxy instanceof _EventProxy2.default) {
               entry.eventProxy.destroy();
            }

            var pluginData = this.getPluginData(pluginName);

            this._pluginMap.delete(pluginName);

            // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.
            if (this._eventbus) {
               this._eventbus.trigger('typhonjs:plugin:manager:plugin:removed', pluginData);
            }

            return true;
         }

         return false;
      }

      /**
       * Removes a plugin by name after unloading it and clearing any event bindings automatically.
       *
       * @param {string}   pluginName - The plugin name to remove.
       *
       * @returns {Promise<boolean>} - Operation success.
       */

   }, {
      key: 'removeAsync',
      value: function () {
         var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(pluginName) {
            var entry, pluginData;
            return _regenerator2.default.wrap(function _callee5$(_context5) {
               while (1) {
                  switch (_context5.prev = _context5.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context5.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        entry = this._pluginMap.get(pluginName);

                        if (!(entry instanceof _PluginEntry2.default)) {
                           _context5.next = 14;
                           break;
                        }

                        _context5.next = 6;
                        return s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, pluginName, this._pluginMap, this._options, false);

                     case 6:

                        // Automatically remove any potential reference to a stored event proxy instance.
                        try {
                           entry.instance._eventbus = void 0;
                        } catch (err) {/* nop */}

                        if (entry.eventProxy instanceof _EventProxy2.default) {
                           entry.eventProxy.destroy();
                        }

                        pluginData = this.getPluginData(pluginName);


                        this._pluginMap.delete(pluginName);

                        // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.

                        if (!this._eventbus) {
                           _context5.next = 13;
                           break;
                        }

                        _context5.next = 13;
                        return this._eventbus.triggerAsync('typhonjs:plugin:manager:plugin:removed', pluginData);

                     case 13:
                        return _context5.abrupt('return', true);

                     case 14:
                        return _context5.abrupt('return', false);

                     case 15:
                     case 'end':
                        return _context5.stop();
                  }
               }
            }, _callee5, this);
         }));

         function removeAsync(_x30) {
            return _ref5.apply(this, arguments);
         }

         return removeAsync;
      }()

      /**
       * Removes all plugins after unloading them and clearing any event bindings automatically.
       */

   }, {
      key: 'removeAll',
      value: function removeAll() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         var _iteratorNormalCompletion21 = true;
         var _didIteratorError21 = false;
         var _iteratorError21 = undefined;

         try {
            for (var _iterator21 = (0, _getIterator3.default)(this._pluginMap.keys()), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
               var pluginName = _step21.value;

               this.remove(pluginName);
            }
         } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion21 && _iterator21.return) {
                  _iterator21.return();
               }
            } finally {
               if (_didIteratorError21) {
                  throw _iteratorError21;
               }
            }
         }

         this._pluginMap.clear();
      }

      /**
       * Removes all plugins after unloading them and clearing any event bindings automatically.
       *
       * @returns {Promise.<*>}
       */

   }, {
      key: 'removeAllAsync',
      value: function removeAllAsync() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         var values = [];

         var _iteratorNormalCompletion22 = true;
         var _didIteratorError22 = false;
         var _iteratorError22 = undefined;

         try {
            for (var _iterator22 = (0, _getIterator3.default)(this._pluginMap.keys()), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
               var pluginName = _step22.value;

               values.push(this.remove(pluginName));
            }
         } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
         } finally {
            try {
               if (!_iteratorNormalCompletion22 && _iterator22.return) {
                  _iterator22.return();
               }
            } finally {
               if (_didIteratorError22) {
                  throw _iteratorError22;
               }
            }
         }

         this._pluginMap.clear();

         return _promise2.default.all(values);
      }

      /**
       * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables
       * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.
       *
       * @param {string}   pluginName - The plugin name to remove.
       *
       * @returns {boolean} - Operation success.
       * @private
       */

   }, {
      key: '_removeEventbus',
      value: function _removeEventbus(pluginName) {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         return !this._options.noEventRemoval ? this.remove(pluginName) : false;
      }

      /**
       * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables
       * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.
       *
       * @param {string}   pluginName - The plugin name to remove.
       *
       * @returns {Promise<boolean>} - Operation success.
       * @private
       */

   }, {
      key: '_removeEventbusAsync',
      value: function () {
         var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(pluginName) {
            return _regenerator2.default.wrap(function _callee6$(_context6) {
               while (1) {
                  switch (_context6.prev = _context6.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context6.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        if (this._options.noEventRemoval) {
                           _context6.next = 8;
                           break;
                        }

                        _context6.next = 5;
                        return this.removeAsync(pluginName);

                     case 5:
                        _context6.t0 = _context6.sent;
                        _context6.next = 9;
                        break;

                     case 8:
                        _context6.t0 = _promise2.default.resolve(false);

                     case 9:
                        return _context6.abrupt('return', _context6.t0);

                     case 10:
                     case 'end':
                        return _context6.stop();
                  }
               }
            }, _callee6, this);
         }));

         function _removeEventbusAsync(_x31) {
            return _ref6.apply(this, arguments);
         }

         return _removeEventbusAsync;
      }()

      /**
       * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables
       * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.
       *
       * @private
       */

   }, {
      key: '_removeAllEventbus',
      value: function _removeAllEventbus() {
         if (this._pluginMap === null) {
            throw new ReferenceError('This PluginManager instance has been destroyed.');
         }

         if (!this._options.noEventRemoval) {
            this.removeAll();
         }
      }

      /**
       * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables
       * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.
       *
       * @private
       */

   }, {
      key: '_removeAllEventbusAsync',
      value: function () {
         var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
            return _regenerator2.default.wrap(function _callee7$(_context7) {
               while (1) {
                  switch (_context7.prev = _context7.next) {
                     case 0:
                        if (!(this._pluginMap === null)) {
                           _context7.next = 2;
                           break;
                        }

                        throw new ReferenceError('This PluginManager instance has been destroyed.');

                     case 2:
                        if (this._options.noEventRemoval) {
                           _context7.next = 5;
                           break;
                        }

                        _context7.next = 5;
                        return this.removeAll();

                     case 5:
                     case 'end':
                        return _context7.stop();
                  }
               }
            }, _callee7, this);
         }));

         function _removeAllEventbusAsync() {
            return _ref7.apply(this, arguments);
         }

         return _removeAllEventbusAsync;
      }()
   }]);
   return PluginManager;
}();

/**
 * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for
 * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.
 *
 * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin
 * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.
 *
 * @param {string}                     methodName - Method name to invoke.
 *
 * @param {object}                     copyProps - plugin event object.
 *
 * @param {object}                     passthruProps - if true, event has plugin option.
 *
 * @param {*}                          extraEventData - Optional extra data attached to all plugin events.
 *
 * @param {string|Array<string>}       nameOrList - An optional plugin name or array / iterable of plugin names to
 *                                                  invoke.
 *
 * @param {Map<string, PluginEvent>}   pluginMap - Stores the plugins by name with an associated PluginEntry.
 *
 * @param {object}                     options - Defines options for throwing exceptions. Turned off by default.
 *
 * @param {boolean}                    [performErrorCheck=true] - If false optional error checking is disabled.
 *
 * @returns {Promise<PluginEvent>}
 */


exports.default = PluginManager;
var s_INVOKE_ASYNC_EVENTS = function () {
   var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(methodName) {
      var copyProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var passthruProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var extraEventData = arguments[3];
      var nameOrList = arguments[4];
      var pluginMap = arguments[5];
      var options = arguments[6];
      var performErrorCheck = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;

      var pluginInvokeCount, pluginInvokeNames, hasMethod, hasPlugin, ev, results, entry, result, _iteratorNormalCompletion23, _didIteratorError23, _iteratorError23, _iterator23, _step23, name, _entry3, _result;

      return _regenerator2.default.wrap(function _callee8$(_context8) {
         while (1) {
            switch (_context8.prev = _context8.next) {
               case 0:
                  if (!(typeof methodName !== 'string')) {
                     _context8.next = 2;
                     break;
                  }

                  throw new TypeError('\'methodName\' is not a string.');

               case 2:
                  if (!((typeof passthruProps === 'undefined' ? 'undefined' : (0, _typeof3.default)(passthruProps)) !== 'object')) {
                     _context8.next = 4;
                     break;
                  }

                  throw new TypeError('\'passthruProps\' is not an object.');

               case 4:
                  if (!((typeof copyProps === 'undefined' ? 'undefined' : (0, _typeof3.default)(copyProps)) !== 'object')) {
                     _context8.next = 6;
                     break;
                  }

                  throw new TypeError('\'copyProps\' is not an object.');

               case 6:
                  if (!(typeof nameOrList !== 'string' && !Array.isArray(nameOrList) && typeof nameOrList[_iterator26.default] !== 'function')) {
                     _context8.next = 8;
                     break;
                  }

                  throw new TypeError('\'nameOrList\' is not a string, array, or iterator.');

               case 8:

                  // Track how many plugins were invoked.
                  pluginInvokeCount = 0;
                  pluginInvokeNames = [];

                  // Track if a plugin method is invoked

                  hasMethod = false;
                  hasPlugin = false;

                  // Create plugin event.

                  ev = new _PluginEvent2.default(copyProps, passthruProps, extraEventData);
                  results = [];

                  if (!(typeof nameOrList === 'string')) {
                     _context8.next = 19;
                     break;
                  }

                  entry = pluginMap.get(nameOrList);


                  if (entry instanceof _PluginEntry2.default && entry.enabled && entry.instance) {
                     hasPlugin = true;

                     if (typeof entry.instance[methodName] === 'function') {
                        ev.eventbus = entry.eventProxy;
                        ev.pluginName = entry.name;
                        ev.pluginOptions = entry.data.plugin.options;

                        result = entry.instance[methodName](ev);


                        if (typeof result !== 'undefined' && result !== null) {
                           results.push(result);
                        }

                        hasMethod = true;
                        pluginInvokeCount++;
                        pluginInvokeNames.push(entry.name);
                     }
                  }
                  _context8.next = 38;
                  break;

               case 19:
                  _iteratorNormalCompletion23 = true;
                  _didIteratorError23 = false;
                  _iteratorError23 = undefined;
                  _context8.prev = 22;

                  for (_iterator23 = (0, _getIterator3.default)(nameOrList); !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                     name = _step23.value;
                     _entry3 = pluginMap.get(name);


                     if (_entry3 instanceof _PluginEntry2.default && _entry3.enabled && _entry3.instance) {
                        hasPlugin = true;

                        if (typeof _entry3.instance[methodName] === 'function') {
                           ev.eventbus = _entry3.eventProxy;
                           ev.pluginName = _entry3.name;
                           ev.pluginOptions = _entry3.data.plugin.options;

                           _result = _entry3.instance[methodName](ev);


                           if (typeof _result !== 'undefined' && _result !== null) {
                              results.push(_result);
                           }

                           hasMethod = true;
                           pluginInvokeCount++;
                           pluginInvokeNames.push(_entry3.name);
                        }
                     }
                  }
                  _context8.next = 30;
                  break;

               case 26:
                  _context8.prev = 26;
                  _context8.t0 = _context8['catch'](22);
                  _didIteratorError23 = true;
                  _iteratorError23 = _context8.t0;

               case 30:
                  _context8.prev = 30;
                  _context8.prev = 31;

                  if (!_iteratorNormalCompletion23 && _iterator23.return) {
                     _iterator23.return();
                  }

               case 33:
                  _context8.prev = 33;

                  if (!_didIteratorError23) {
                     _context8.next = 36;
                     break;
                  }

                  throw _iteratorError23;

               case 36:
                  return _context8.finish(33);

               case 37:
                  return _context8.finish(30);

               case 38:
                  if (!(performErrorCheck && options.throwNoPlugin && !hasPlugin)) {
                     _context8.next = 40;
                     break;
                  }

                  throw new Error('PluginManager failed to find any target plugins.');

               case 40:
                  if (!(performErrorCheck && options.throwNoMethod && !hasMethod)) {
                     _context8.next = 42;
                     break;
                  }

                  throw new Error('PluginManager failed to invoke \'' + methodName + '\'.');

               case 42:

                  // Add meta data for plugin invoke count.
                  ev.data.$$plugin_invoke_count = pluginInvokeCount;
                  ev.data.$$plugin_invoke_names = pluginInvokeNames;

                  _context8.next = 46;
                  return _promise2.default.all(results);

               case 46:
                  return _context8.abrupt('return', ev.data);

               case 47:
               case 'end':
                  return _context8.stop();
            }
         }
      }, _callee8, undefined, [[22, 26, 30, 38], [31,, 33, 37]]);
   }));

   return function s_INVOKE_ASYNC_EVENTS(_x32) {
      return _ref8.apply(this, arguments);
   };
}();

/**
 * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for
 * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.
 *
 * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.
 *
 * @param {string}                     methodName - Method name to invoke.
 *
 * @param {object}                     copyProps - plugin event object.
 *
 * @param {object}                     passthruProps - if true, event has plugin option.
 *
 * @param {*}                          extraEventData - Optional extra data attached to all plugin events.
 *
 * @param {string|Array<string>}       nameOrList - An optional plugin name or array / iterable of plugin names to
 *                                                  invoke.
 *
 * @param {Map<string, PluginEvent>}   pluginMap - Stores the plugins by name with an associated PluginEntry.
 *
 * @param {object}                     options - Defines options for throwing exceptions. Turned off by default.
 *
 * @param {boolean}                    [performErrorCheck=true] - If false optional error checking is disabled.
 *
 * @returns {PluginEvent}
 */
var s_INVOKE_SYNC_EVENTS = function s_INVOKE_SYNC_EVENTS(methodName) {
   var copyProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
   var passthruProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
   var extraEventData = arguments[3];
   var nameOrList = arguments[4];
   var pluginMap = arguments[5];
   var options = arguments[6];
   var performErrorCheck = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;

   if (typeof methodName !== 'string') {
      throw new TypeError('\'methodName\' is not a string.');
   }
   if ((typeof passthruProps === 'undefined' ? 'undefined' : (0, _typeof3.default)(passthruProps)) !== 'object') {
      throw new TypeError('\'passthruProps\' is not an object.');
   }
   if ((typeof copyProps === 'undefined' ? 'undefined' : (0, _typeof3.default)(copyProps)) !== 'object') {
      throw new TypeError('\'copyProps\' is not an object.');
   }

   if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) && typeof nameOrList[_iterator26.default] !== 'function') {
      throw new TypeError('\'nameOrList\' is not a string, array, or iterator.');
   }

   // Track how many plugins were invoked.
   var pluginInvokeCount = 0;
   var pluginInvokeNames = [];

   // Track if a plugin method is invoked
   var hasMethod = false;
   var hasPlugin = false;

   // Create plugin event.
   var ev = new _PluginEvent2.default(copyProps, passthruProps, extraEventData);

   if (typeof nameOrList === 'string') {
      var entry = pluginMap.get(nameOrList);

      if (entry instanceof _PluginEntry2.default && entry.enabled && entry.instance) {
         hasPlugin = true;

         if (typeof entry.instance[methodName] === 'function') {
            ev.eventbus = entry.eventProxy;
            ev.pluginName = entry.name;
            ev.pluginOptions = entry.data.plugin.options;

            entry.instance[methodName](ev);

            hasMethod = true;
            pluginInvokeCount++;
            pluginInvokeNames.push(entry.name);
         }
      }
   } else {
      var _iteratorNormalCompletion24 = true;
      var _didIteratorError24 = false;
      var _iteratorError24 = undefined;

      try {
         for (var _iterator24 = (0, _getIterator3.default)(nameOrList), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
            var name = _step24.value;

            var _entry4 = pluginMap.get(name);

            if (_entry4 instanceof _PluginEntry2.default && _entry4.enabled && _entry4.instance) {
               hasPlugin = true;

               if (typeof _entry4.instance[methodName] === 'function') {
                  ev.eventbus = _entry4.eventProxy;
                  ev.pluginName = _entry4.name;
                  ev.pluginOptions = _entry4.data.plugin.options;

                  _entry4.instance[methodName](ev);

                  hasMethod = true;
                  pluginInvokeCount++;
                  pluginInvokeNames.push(_entry4.name);
               }
            }
         }
      } catch (err) {
         _didIteratorError24 = true;
         _iteratorError24 = err;
      } finally {
         try {
            if (!_iteratorNormalCompletion24 && _iterator24.return) {
               _iterator24.return();
            }
         } finally {
            if (_didIteratorError24) {
               throw _iteratorError24;
            }
         }
      }
   }

   if (performErrorCheck && options.throwNoPlugin && !hasPlugin) {
      throw new Error('PluginManager failed to find any target plugins.');
   }

   if (performErrorCheck && options.throwNoMethod && !hasMethod) {
      throw new Error('PluginManager failed to invoke \'' + methodName + '\'.');
   }

   // Add meta data for plugin invoke count.
   ev.data.$$plugin_invoke_count = pluginInvokeCount;
   ev.data.$$plugin_invoke_names = pluginInvokeNames;

   return ev.data;
};

/**
 * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.
 *
 * @param {object}   obj - object to walks.
 *
 * @returns {Array}
 * @ignore
 */
var s_GET_ALL_PROPERTY_NAMES = function s_GET_ALL_PROPERTY_NAMES(obj) {
   var props = [];

   do {
      (0, _getOwnPropertyNames2.default)(obj).forEach(function (prop) {
         if (props.indexOf(prop) === -1) {
            props.push(prop);
         }
      });
      obj = (0, _getPrototypeOf2.default)(obj);
   } while (typeof obj !== 'undefined' && obj !== null && !(obj === Object.prototype));

   return props;
};
module.exports = exports['default'];